3、接下来，我们需要把这个原始密钥送到腾讯的服务器进行验证，并返回令牌结果写下这个标题的时候，您可能要问，webqq登录协议有什么用?很简单，qq所有产品都是采用统一的登录协议加密登录的也就是说，当您能够通过使用它的协议来登录并获取到令牌后，那么就可以任意的使用qq的各项产品了，如webqq，空间，微博，校友等等的而本文主要就是讲述下如何通过技术手段来使用webqq的协议，从而获取到登录令牌所有完整的源代码，可以从我的开源项目CDMSYSTEM中的pushblog插件获取并且试用地址是：一、腾讯产品的登录与验证过程
腾讯产品的登录一共需要经过三次验证，分别是在登录页面1、验证帐号状态，并通过帐号获取令牌的原始密钥；2、对原始密钥进行运算生成令牌密钥并提交服务器，服务器进行一次验证；3、经过第二次验证通过，服务器自动跳转，进行第三此验证，最后返回登录令牌…终成功后才能获取到加密过后的登录令牌，而利用此令牌就可以顺利的操作任何腾讯的产品与服务了接下来我们以腾讯微博为例来进行一些在合法的限度内的讲解，旨在开拓各位读者的思维与分享技术思路，因此如果您抱着想要通过本文的讲解来进行获利的目的，那我建议您可以就此打住了因为，接下来的内容中我并不会去讲解或者说分享那些您会感兴趣的东西 
二、协议详解
1、言归正传，首先第一次的登录是发生在我们打开登录页面的时候还是以腾讯微博为例，当我们打开微博的登录页面时，页面上的js会触发一个地址：这个地址是用来判断您的用户名是否是正常状态，以及是否有效用户名，并返回一个状态值以及一个验证码其中uin就是你的用户名，appid指的是腾讯产品的编码r是一个随机生成的数字，用来避免浏览器缓存
正常时，请求这个地址，会获得类似ptui_checkVC('0','！AFO')；这样的返回值，这其中0是代表正常状态，不采用图片验证但是如果短时间内这个帐号多次在不同的ip登录，那么返回值就是另外的一种返回值了，那表明需要进行图片验证码验证此外，0还有可能变为其他的数值，用来标明诸如帐号不存在，帐号状态不正确，帐号已锁定等等的而后面的！AFO是四位则是我们需要获得的原始令牌值，它是由腾讯服务器随机生成的一个令牌的原始密钥当然也许您在获取的时候会发现这个值并不是4位，而是很多位那么就要恭喜您了，您获得也是令牌的原始密钥，只不过不同的是，您获得是图片验证码的原始密钥而已 
当然其实图形验证码的自动识别也很简单，只是这已经超出本文的范围了，以后有机会可以与大家再次分享下此时，当我们正确的获得！AFO时就已经完成了第一次的验证！但是有一点需要注意的是：腾讯的令牌是存储在cookies中的，
所以请注意每次操作都必须要保存好服务器返回来的cookies以下为python语言写的的示例代码，此代码可以从中的pushmodel.py文件中获取
defGet_qq_msg_val(self,username,password)：verifyURL='(username,random.random())loginURL='redirectURL=''cookie=''qqn=usernamemd5Pass=''verifyCode=''result=urlfetch.fetch(url=verifyURL,method=urlfetch.GET,follow_redirects=False,headers={'Content-Type'：'application/x-www-form-urlencoded','user-agent'：'Mozilla/5.0(Linux；U；Linuxi686；en-US)AppleWebKit/525.13(KHTML,likeGecko)Chrome/0.4.2.80Safari/525.13',},)cookie1=Cookie.SimpleCookie(result.headers.get('set-cookie',''))verifyCode=result.content[18：-3]iflen(verifyCode)4：returnFalse,NoneloginURL+="u=%s&p="%usernameloginURL+=self.EncodePasswordWithVerifyCode(password,verifyCode)loginURL+="&verifycode="+verifyCode+"&aid=46000101&u1=http%3A%2F%2Ft.qq.com&ptredirect=1&h=1&from_ui=1&fp=loginerroralert"result=urlfetch.fetch(url=loginURL,headers={'Referer'：''Cookie'：self.make_cookie_header(cookie1),'Content-Type'：'application/x-www-form-urlencoded','user-agent'：'Mozilla/5.0(Linux；U；Linuxi686；en-US)AppleWebKit/525.13(KHTML,likeGecko)Chrome/0.4.2.80Safari/525.13',},method=urlfetch.GET,follow_redirects=False,)setCookies=result.headers.get('set-cookie','').split('；')cookie2=''cookie2+=setCookies[29]cookie2+=setCookies[7]cookie2+=setCookies[4]cookie2+='；'+setCookies[0]cookie2=cookie2.replace(',','；')cookie2=cookie2[1：]callback_url=result.headers.get('location','result,cookies=self.do_redirect(callback_url,cookie2)returnresult,cookies2、此时我们需要对获取到的原始密钥进行一系列的运算，从而得到令牌密钥这个算法其实也很简单，就是先把用户密码连续进行两次md5加密，每次md5加密输出二进制的结果，然后在对经过两次md5加密后的结果在进行一次md5加密，最后输出16进制大写的结果在把我们第一步获取到的原始密钥合并在此结果之后，形成一个新的字符串并且再次对此字符串进行md5加密，并输出16进制大写的字符串此时，此字符串就为令牌密钥了示例代码如下 
defmd5hash(self,str)：returnhashlib.md5(str).digest()defhex_md5hash(self,str)：returnhashlib.md5(str).hexdigest().upper()defmd5hash_3(self,str)：returnself.hex_md5hash(self.md5hash(self.md5hash(str)))defEncodePasswordWithVerifyCode(self,pwd,verifyCode)：returnself.hex_md5hash(self.md5hash_3(pwd)+verifyCode.upper())EncodePasswordWithVerifyCode()即为此加密算法，pwd是密码，verifyCode为我们第一步获取到的4位的原始密钥服务器的地址为：这其中，u代表是用户帐号，p就是我们第二步所生成的令牌密钥，verifycode为我们第一步获取的原始密钥，u1为我们登录的产品地址，至于后面的那些参数不用管它，写什么都无所谓的我们只要生成此链接并请求后，服务器通过验证就会返回给我们最终的令牌只是此令牌并不是返回一组数据，而是全部以cookies的形式返回这是我们需要注意的第一点，其次是当我们请求此地址时，此地址会返回如下的cookiespt2gguino0939567050/qq.comFri,02-Jan-202000：00：00GMTuino0939567050/qq.comEndOfSessionskey@aw6EH0ljo/qq.comEndOfSessionclientuin/qq.comFri,02-Jan-197000：00：00GMTclientkey/qq.comFri,02-Jan-197000：00：00GMTzzpaneluin/qq.comFri,02-Jan-197000：00：00GMTzzpanelkey/qq.comFri,02-Jan-197000：00：00GMTptispctc/qq.comEndOfSessionptczf41721c4e7bc752fdeae10c9cb2db66ca66af1049a4835185acfdfe2a26860e5/qq.comFri,02-Jan-202000：00：00GMTairkey/qq.comFri,02-Jan-197000：00：00GMT这其中其他的都不用解释了，看命名就知道作用了我要提醒的是，skey这个cookie以及ptcz是关键为什么呢?因为skey这个值，在很多地方都非常有用，比如添加好友，或者qzone发布日志，都需要对此值进行验证当然最保险的方法仍旧是cookies每次一次的都保留起来，一个都不放过，哈哈 
接下来当此地址验证通过后，腾讯会给你添加如上的cookies然后自动跳转到最后一个验证页面，一般来说此页面为你登录服务的主页，但是也有例外，比如qzone，就是一个successd的页面这个自己嗅探一下就可以了
还是以qq微博为例，这一步会跳转到t.qq.com页面去，在这个页面中会返回给一个诸如：mb_juneSjrVWJyAbfrtNS5yh0cbbcZtCr%2FIvvqtBwVtFE6JCG4G0CY46WdpVX1%2FnGuAfXZE/t.qq.comMon,20-Sep-201014：48：27GMT这样的cookies值此时，算是令牌已经获取到了解析来，只要你一直保存有这些cookies，就可以操作腾讯任意的服务了需要提醒大家注意一点就是，这个令牌是通用的，也就是你是在t.qq.com登录与获取的令牌,但是通过此令牌一样的可以操作webqq或者qzone，而不用再次的进行登录了
defdo_redirect(self,url,cookie)：logging.info(url)result=urlfetch.fetch(url=url,headers={'Cookie'：cookie,'Content-Type'：'application/x-www-form-urlencoded','user-agent'：'Mozilla/5.0(Linux；U；Linuxi686；en-US)AppleWebKit/525.13(KHTML,likeGecko)Chrome/0.4.2.80Safari/525.13',},method=urlfetch.GET,follow_redirects=False,)returnresult,cookie三、如何操作腾讯的应用服务 
这个其实就是苦功夫了，你可以通过socket直接与服务器进行通讯，或者使用webqq的协议，或者使用腾讯每个服务自己的web页面的接口来实现但是，这些都需要您去进行嗅探并且分析协议的内容相对来说，web页面直接的接口是最简单的，无非就是post表单过去，或者对页面进行get请求，然后得到返回值，在对返回值进行操作并再次的发起请求而已其次是webqq协议也相对好解决它是通过与(24这个数字是可以变化的，具体看你使用哪个服务器了，这只是腾讯的通信代理服务器)进行json格式的数据交换而已，而且所有信息都是明文的，也很好理解自己尝试一段时间，就能搞清楚协议中每个参数以及api的含义了对此，李昱有利用业余时间做了一个qq聊天机器人玩，但是讲起来太多了，也太敏感了，因此本文并不进行探讨，以后有空在与大家进行分享下面就简单的给出发布qq微博与qzone文章的代码以便于大家理解，具体不再进行解释了 
qq微博的发送代码：
defsend_qq_msgs(self,username,password,msg,memcachekey)："""sendsinamsgs.useqqusername,password.themsgsparameterisamessagelist,notasinglestring."""cookie=''ifmemcache.get(memcachekey)：cookie=memcache.get(memcachekey)else：result,oldcookie=self.Get_qq_msg_val(username,password)ifresult==False：returnFalsecookie='%s；%s'%(result.headers.get('set-cookie',''),oldcookie)memcache.set(memcachekey,cookie,36000)msg=unescape(msg)form_fields={"content"：msg,"pic"：'',"countType"：'',"viewModel"：1}form_data=urllib.urlencode(form_fields)try：result=urlfetch.fetch(url="payload=form_data,method=urlfetch.POST,headers={'Referer'：''Cookie'：cookie,'user-agent'：'Mozilla/5.0(Linux；U；Linuxi686；en-US)AppleWebKit/525.13(KHTML,likeGecko)Chrome/0.4.2.80Safari/525.13',},follow_redirects=False)except：returnFalseifresult.status_code==200：returnTrueelse：returnFalse